//=== lib/Target/pISA/pISALegalizeSubregAccess.cpp ------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This pass enforces restrictions on instructions that may not be able to
// handle a given subreg access (as generated by e.g., register coalescing).
//
//===----------------------------------------------------------------------===//

#include "pISA.h"
#include "pISASubtarget.h"
#include "pISAMCInstLower.h"
#include "llvm/Target/TargetMachine.h"

#define DEBUG_TYPE "pisa-legalize-subreg-access"

using namespace llvm;

namespace {

class pISALegalizeSubregAccess : public MachineFunctionPass {
public:
  static char ID;

  pISALegalizeSubregAccess();

  StringRef getPassName() const override {
    return "pISALegalizeSubregAccess";
  }

  bool runOnMachineFunction(MachineFunction &MF) override;

  void getAnalysisUsage(AnalysisUsage &AU) const override;
};
} // end anonymous namespace

void pISALegalizeSubregAccess::getAnalysisUsage(AnalysisUsage &AU) const {
  AU.setPreservesCFG();
  MachineFunctionPass::getAnalysisUsage(AU);
}

pISALegalizeSubregAccess::pISALegalizeSubregAccess()
  : MachineFunctionPass(ID) {
  initializepISALegalizeSubregAccessPass(*PassRegistry::getPassRegistry());
}

bool pISALegalizeSubregAccess::runOnMachineFunction(MachineFunction &MF) {
  auto& ST = MF.getSubtarget<pISASubtarget>();
  auto* TII = ST.getInstrInfo();
  auto* TRI = ST.getRegisterInfo();
  auto& MRI = MF.getRegInfo();
  bool Changed = false;
  SmallVector<MachineInstr*, 8> FnArgs;
  SmallVector<MachineInstr*> ManyArgs;
  for (auto& MBB : MF) {
    for (auto& MI : MBB) {
      if (TII->isFunctionParamInstr(MI))
        FnArgs.push_back(&MI);
      else if (MI.getNumOperands() > pISAMCInstLower::MAX_ENCODED_ARGS)
        ManyArgs.push_back(&MI);
    }
  }

  for (auto* MI : reverse(FnArgs)) {
    auto& Dst = MI->getOperand(0);
    unsigned Subreg = Dst.getSubReg();
    if (Subreg == 0)
      continue;

    Changed = true;

    auto* RC = TII->getRegClass(TII->get(MI->getOpcode()), 0, TRI, MF);
    Register NewDstReg = MRI.createVirtualRegister(RC);

    MachineInstr* CopyMI =
      BuildMI(MF, MI->getDebugLoc(), TII->get(TargetOpcode::COPY))
      .add(Dst)
      .addReg(NewDstReg);

    auto* InsertPt = FnArgs[FnArgs.size() - 1];

    Dst.setReg(NewDstReg);
    Dst.setSubReg(0);
    Dst.setIsUndef(false);
    MI->getParent()->insertAfter(InsertPt, CopyMI);
  }

  for (auto* MI : ManyArgs) {
    for (unsigned OpNo = pISAMCInstLower::MAX_ENCODED_ARGS;
         OpNo < MI->getNumOperands(); OpNo++) {
      auto& Src = MI->getOperand(OpNo);
      if (!Src.isReg() || Src.getSubReg() == 0)
        continue;

      Changed = true;

      DebugLoc DL = MI->getDebugLoc();
      auto* NewRC = TRI->getSubRegisterClass(
        MRI.getRegClass(Src.getReg()),
        Src.getSubReg());
      assert(NewRC && "couldn't find subreg regclass?");
      Register NewSrcReg = MRI.createVirtualRegister(NewRC);
      BuildMI(*MI->getParent(), MI, DL, TII->get(TargetOpcode::COPY), NewSrcReg)
        .add(Src);

      Src.setReg(NewSrcReg);
      Src.setSubReg(0);
    }
  }

  return Changed;
}

char pISALegalizeSubregAccess::ID = 0;
INITIALIZE_PASS_BEGIN(pISALegalizeSubregAccess, DEBUG_TYPE,
                      "Legalize unhandled subreg accesses",
                      false, false)
INITIALIZE_PASS_END(pISALegalizeSubregAccess, DEBUG_TYPE,
                    "Legalize unhandled subreg accesses", false,
                    false)

namespace llvm {
FunctionPass *createpISALegalizeSubregAccess() {
  return new pISALegalizeSubregAccess();
}
} // end namespace llvm
