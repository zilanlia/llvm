//===- pISAInstructionSelector.cpp ------------------------------*- C++ -*-==//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file implements the targeting of the InstructionSelector class for
// pISA.
// TODO: This should be generated by TableGen.
//
//===----------------------------------------------------------------------===//

#include "pISA.h"
#include "pISAInstrInfo.h"
#include "pISARegisterBankInfo.h"
#include "pISARegisterInfo.h"
#include "pISATargetMachine.h"
#include "pISAUtils.h"
#include "llvm/ADT/APFloat.h"
#include "llvm/ADT/FloatingPointMode.h"
#include "llvm/CodeGen/GlobalISel/InstructionSelector.h"
// #include "llvm/CodeGen/GlobalISel/InstructionSelectorImpl.h"
#include "llvm/CodeGen/GlobalISel/GIMatchTableExecutorImpl.h"
#include "llvm/CodeGen/GlobalISel/MIPatternMatch.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/IR/IntrinsicspISA.h"
#include "llvm/Support/Debug.h"
#include "llvm/CodeGen/GlobalISel/MachineIRBuilder.h"

#define DEBUG_TYPE "pISA-isel"

using namespace llvm;
using namespace MIPatternMatch;

namespace {

#define GET_GLOBALISEL_PREDICATE_BITSET
#include "pISAGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATE_BITSET

class pISAInstructionSelector : public InstructionSelector {
  const pISATargetMachine &TMI;
  const pISASubtarget &STI;
  const pISAInstrInfo &TII;
  const pISARegisterInfo &TRI;
  const RegisterBankInfo &RBI;
  MachineRegisterInfo *MRI;

public:
  pISAInstructionSelector(const pISATargetMachine &TM,
                           const pISASubtarget &ST,
                           const RegisterBankInfo &RBI);
  void setupMF(MachineFunction &MF, GISelKnownBits *KB,
               CodeGenCoverage &CoverageInfo, ProfileSummaryInfo *PSI,
               BlockFrequencyInfo *BFI);
  bool select(MachineInstr &I) override;
  static const char *getName() { return DEBUG_TYPE; }

#define GET_GLOBALISEL_PREDICATES_DECL
#include "pISAGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_DECL

#define GET_GLOBALISEL_TEMPORARIES_DECL
#include "pISAGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_DECL

private:
  // tblgen-erated 'select' implementation, used as the initial selector for
  // the patterns that don't require complex C++.
  bool selectImpl(MachineInstr &I, CodeGenCoverage &CoverageInfo) const;
  bool selectFrameIndex(MachineInstr &I) const;
  bool selectGlobalValue(MachineInstr &I) const;
  bool selectPhiOrImplicitDef(MachineInstr &I) const;
  bool selectFastFP(MachineInstr &I) const;
  bool selectAddSubWithOverflow(MachineInstr &I) const;
  bool selectBitcast(MachineInstr &I) const;
  bool selectUnmergeValues(MachineInstr &I) const;
  bool selectBuildVector(MachineInstr &I) const;
  bool selectFPTruncRound(MachineInstr &I) const;
  bool selectConvPtrInt(MachineInstr &I) const;
  bool selectCopy(MachineInstr &I) const;
  bool selectG_INTRINSIC(MachineInstr &I) const;
  bool selectDbgValue(MachineInstr &I) const;

  InstructionSelector::ComplexRendererFns SelectAddr_r (MachineOperand &Root) const;
  InstructionSelector::ComplexRendererFns SelectAddr_rr(MachineOperand &Root) const;
  InstructionSelector::ComplexRendererFns SelectAddr_ri(MachineOperand &Root) const;

  bool emitBuildVector(
    MachineInstr& InsertPt, Register DstReg, ArrayRef<Register> Srcs) const;

  bool useFastFP(const MachineInstr &I) const {
    return (TMI.Options.UnsafeFPMath || I.getFlag(MachineInstr::MIFlag::FmAfn));
  }
};

} // end anonymous namespace

#define GET_GLOBALISEL_IMPL
#include "pISAGenGlobalISel.inc"
#undef GET_GLOBALISEL_IMPL

pISAInstructionSelector::pISAInstructionSelector(const pISATargetMachine &TM,
                                                   const pISASubtarget &ST,
                                                   const RegisterBankInfo &RBI)
    : InstructionSelector(), TMI(TM), STI(ST), TII(*ST.getInstrInfo()),
      TRI(*ST.getRegisterInfo()), RBI(RBI),
#define GET_GLOBALISEL_PREDICATES_INIT
#include "pISAGenGlobalISel.inc"
#undef GET_GLOBALISEL_PREDICATES_INIT
#define GET_GLOBALISEL_TEMPORARIES_INIT
#include "pISAGenGlobalISel.inc"
#undef GET_GLOBALISEL_TEMPORARIES_INIT
{
}

void pISAInstructionSelector::setupMF(MachineFunction &MF, GISelKnownBits *KB,
                                       CodeGenCoverage &CoverageInfo,
                                       ProfileSummaryInfo *PSI,
                                       BlockFrequencyInfo *BFI) {
  MRI = &MF.getRegInfo();
  InstructionSelector::setupMF(MF, KB, &CoverageInfo, PSI, BFI);
}

bool pISAInstructionSelector::select(MachineInstr &I) {
  assert(I.getParent() && "Instruction should be in a basic block!");
  assert(I.getParent()->getParent() && "Instruction should be in a function!");

  Register Opcode = I.getOpcode();

  // If it's not a GMIR instruction, we've selected it already.
  if (!I.isPreISelOpcode() && Opcode != TargetOpcode::DBG_VALUE) {
    return constrainSelectedInstRegOperands(I, TII, TRI, RBI);
  }

  if (useFastFP(I) && selectFastFP(I)) {
    // Try to generate fast inst if pISA supports it,
    // otherwise generate regular inst
    return true;
  }

  if (selectImpl(I, *CoverageInfo))
    return true;

  if (I.getNumOperands() != I.getNumExplicitOperands()) {
    LLVM_DEBUG(errs() << "Generic instr has unexpected implicit operands\n");
    return false;
  }

  switch (Opcode) {
  case TargetOpcode::G_FRAME_INDEX:
    return selectFrameIndex(I);
  case TargetOpcode::G_GLOBAL_VALUE:
    return selectGlobalValue(I);
  case TargetOpcode::G_PHI:
  case TargetOpcode::G_IMPLICIT_DEF:
    return selectPhiOrImplicitDef(I);
  case TargetOpcode::G_UADDO:
  case TargetOpcode::G_USUBO:
  case TargetOpcode::G_UADDE:
  case TargetOpcode::G_USUBE:
    return selectAddSubWithOverflow(I);
  case TargetOpcode::G_BITCAST:
    return selectBitcast(I);
  case TargetOpcode::G_UNMERGE_VALUES:
    return selectUnmergeValues(I);
  case TargetOpcode::G_BUILD_VECTOR:
    return selectBuildVector(I);
  case TargetOpcode::G_INTRINSIC_FPTRUNC_ROUND:
    return selectFPTruncRound(I);
  case TargetOpcode::G_PTRTOINT:
  case TargetOpcode::G_INTTOPTR:
    return selectConvPtrInt(I);
  case TargetOpcode::G_FREEZE:
    return selectCopy(I);
  case TargetOpcode::G_INTRINSIC:
    return selectG_INTRINSIC(I);
  case TargetOpcode::DBG_VALUE:
    return selectDbgValue(I);
  default: 
    return false;
  }
}

bool pISAInstructionSelector::selectG_INTRINSIC(MachineInstr& I) const {
  // While we want to select special reg intrinsics in tablegen using
  // SpecialRegPat<>, there is an issue in llvm that prevents us from doing
  // so when the output value is a pointer. It fails in:
  // GlobalISelEmitter::createAndImportSelDAGMatcher()
  // because isOutOperandAPointer() will always return false for G_INTRINSIC
  // is its OutOperandList = (outs). This then causes addTypeCheckPredicate()
  // to not generate a pointer matcher, so tablegen fails saying that we have
  // an unsupported type (even though it is an iPTR). Until this is fixed,
  // manually select these cases here.
  MachineRegisterInfo &MRI = I.getMF()->getRegInfo();
  MachineBasicBlock *BB = I.getParent();
  DebugLoc DL = I.getDebugLoc();

  auto copySpecialReg = [&](unsigned PhysReg) {
    Register DstReg = I.getOperand(0).getReg();
    LLT DstTy = MRI.getType(DstReg);
    auto* DstRC = TRI.getRegClassFromLLT(DstTy);
    BuildMI(*BB, &I, DL, TII.get(TargetOpcode::COPY))
      .addDef(DstReg)
      .addReg(PhysReg);
    I.eraseFromParent();
    return RBI.constrainGenericRegister(DstReg, *DstRC, MRI);
  };

  switch (I.getIntrinsicID()) {
  // begin intel embargo
  case Intrinsic::pisa_rt_globalpointer:
    return copySpecialReg(pISA::SpecialReg_RTGlobalPointer);
  case Intrinsic::pisa_rt_ksppointer:
    return copySpecialReg(pISA::SpecialReg_RTKSPPointer);
  // end intel embargo
  default:
    return false;
  }
}

bool pISAInstructionSelector::selectFrameIndex(MachineInstr &I) const {
  I.setDesc(TII.get(pISA::addrof_32b));
  return true;
}

bool pISAInstructionSelector::selectGlobalValue(MachineInstr &I) const {
  I.setDesc(TII.get(pISA::addrof_64b));
  return true;
}

bool pISAInstructionSelector::selectPhiOrImplicitDef(MachineInstr &I) const {
  MachineBasicBlock* BB = I.getParent();
  DebugLoc DL = I.getDebugLoc();
  MachineRegisterInfo& MRI = BB->getParent()->getRegInfo();

  const unsigned DefReg = I.getOperand(0).getReg();
  const LLT DefTy = MRI.getType(DefReg);

  const RegClassOrRegBank& RegClassOrBank = MRI.getRegClassOrRegBank(DefReg);

  const TargetRegisterClass* DefRC =
    RegClassOrBank.dyn_cast<const TargetRegisterClass*>();

  if (!DefRC)
    DefRC = TRI.getRegClassFromLLT(DefTy);

  unsigned Opcode = (I.getOpcode() == TargetOpcode::G_PHI) ?
    TargetOpcode::PHI :
    TargetOpcode::IMPLICIT_DEF;
  I.setDesc(TII.get(Opcode));

  return RBI.constrainGenericRegister(DefReg, *DefRC, MRI);
}

bool pISAInstructionSelector::selectFastFP(MachineInstr &I) const {
  switch (I.getOpcode()) {
  case TargetOpcode::G_FDIV: {
    bool UseFTZ = STI.getTargetLowering()->useFTZ(*MF);
    auto NewInst = BuildMI(*I.getParent(), I, I.getDebugLoc(),
                           UseFTZ ? TII.get(pISA::fdiv_ftz_fastrr)
                                  : TII.get(pISA::fdiv_fastrr))
                       .addDef(I.getOperand(0).getReg())
                       .addUse(I.getOperand(1).getReg())
                       .addUse(I.getOperand(2).getReg())
                       .constrainAllUses(TII, TRI, RBI);
    I.removeFromParent();
    return NewInst;
  }
  default:
    // if fast inst not supported in pISA, will generate regular inst
   break;
  }
  return false;
}

bool pISAInstructionSelector::selectAddSubWithOverflow(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  const DebugLoc &DL = I.getDebugLoc();
  Register Dst0Reg = I.getOperand(0).getReg();
  Register Dst1Reg = I.getOperand(1).getReg();
  const bool IsAdd = I.getOpcode() == TargetOpcode::G_UADDO ||
                     I.getOpcode() == TargetOpcode::G_UADDE;
  const bool HasCarryIn = I.getOpcode() == TargetOpcode::G_UADDE ||
                          I.getOpcode() == TargetOpcode::G_USUBE;

  Register Src0Reg = I.getOperand(2).getReg();
  Register Src1Reg = I.getOperand(3).getReg();

  auto Dst0RC = TRI.getRegClassFromLLT(MRI->getType(Dst0Reg));
  // Is there any reason to support 16b addc/subb?
  assert(Dst0RC == &pISA::Reg32bRegClass || Dst0RC == &pISA::Reg64bRegClass);
  bool Is32b = Dst0RC == &pISA::Reg32bRegClass;

  // TODO: implement constant folding.
  unsigned NoCarryOpc = IsAdd
                            ? (Is32b ? pISA::iadd_co_32rr : pISA::iadd_co_64rr)
                            : (Is32b ? pISA::isub_co_32rr : pISA::isub_co_64rr);
  unsigned CarryOpc =
      IsAdd ? (Is32b ? pISA::iadd_ci_co_32rr : pISA::iadd_ci_co_64rr)
            : (Is32b ? pISA::isub_ci_co_32rr : pISA::isub_ci_co_64rr);

  BuildMI(*BB, &I, DL, TII.get(HasCarryIn ? CarryOpc : NoCarryOpc), Dst0Reg)
      .add(I.getOperand(2))
      .add(I.getOperand(3));

  if (!RBI.constrainGenericRegister(Dst0Reg, *Dst0RC, *MRI) ||
      !RBI.constrainGenericRegister(Src0Reg, *Dst0RC, *MRI) ||
      !RBI.constrainGenericRegister(Src1Reg, *Dst0RC, *MRI))
   return false;

  I.eraseFromParent();
  return true;
}

bool pISAInstructionSelector::selectBitcast(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  DebugLoc DL = I.getDebugLoc();
  MachineRegisterInfo &MRI = BB->getParent()->getRegInfo();

  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg = I.getOperand(1).getReg();
  LLT DstTy = MRI.getType(DstReg);
  LLT SrcTy = MRI.getType(SrcReg);
  auto *DstRC = TRI.getRegClassFromLLT(DstTy);
  auto *SrcRC = TRI.getRegClassFromLLT(SrcTy);

  if (DstTy.getSizeInBits() != SrcTy.getSizeInBits()) {
    assert(false && "Wrong bitcast operands!");
    return false;
  }

  BuildMI(*BB, &I, DL, TII.get(TargetOpcode::COPY))
      .addDef(DstReg)
      .addReg(SrcReg);

  if (!RBI.constrainGenericRegister(SrcReg, *SrcRC, MRI) ||
      !RBI.constrainGenericRegister(DstReg, *DstRC, MRI))
    return false;

  I.eraseFromParent();
  return true;
}

bool pISAInstructionSelector::selectUnmergeValues(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  DebugLoc DL = I.getDebugLoc();
  MachineRegisterInfo &MRI = BB->getParent()->getRegInfo();

  // A sequence of COPY's (subreg to reg) is generated.

  // We also handle the case where the destinations are vectors:
  // %2:_(<2 x s32>), %3:_(<2 x s32>) = G_UNMERGE_VALUES %1(<4 x s32>)

  const int NumDst = I.getNumOperands() - 1;

  Register SrcReg = I.getOperand(NumDst).getReg();
  LLT DstTy = MRI.getType(I.getOperand(0).getReg());
  const unsigned DstNumElts = DstTy.isScalar() ? 1 : DstTy.getNumElements();
  const unsigned DstEltSize = DstTy.getScalarSizeInBits();
  auto *DstRC = TRI.getRegClassFromLLT(DstTy);

  for (int i = 0; i < NumDst; ++i) {
    Register DstReg = I.getOperand(i).getReg();
    SmallVector<Register> Regs;
    for (uint32_t j = 0; j < DstNumElts; j++) {
      unsigned SubRegIdx = TRI.getSubRegIdx(DstEltSize, i * DstNumElts + j);
      Register SubDstReg = (DstNumElts == 1) ?
        DstReg :
        MRI.createGenericVirtualRegister(DstTy.getScalarType());
      BuildMI(*BB, &I, DL, TII.get(TargetOpcode::COPY), SubDstReg)
        .addReg(SrcReg, 0, SubRegIdx);
      Regs.push_back(SubDstReg);
    }

    if (DstNumElts > 1) {
      auto* SubRC = TRI.getRegClassFromLLT(DstTy.getScalarType());
      for (Register R : Regs) {
        if (!RBI.constrainGenericRegister(R, *SubRC, MRI))
          return false;
      }
      if (!emitBuildVector(I, DstReg, Regs))
        return false;
    }

    if (!RBI.constrainGenericRegister(DstReg, *DstRC, MRI))
      return false;
  }

  I.eraseFromParent();
  return true;
}

bool pISAInstructionSelector::selectConvPtrInt(MachineInstr &I) const {
  // Custom select G_PTRTOINT and G_INTTOPTR
  MachineBasicBlock *BB = I.getParent();
  DebugLoc DL = I.getDebugLoc();
  MachineRegisterInfo &MRI = BB->getParent()->getRegInfo();

  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg = I.getOperand(1).getReg();

  LLT DstTy = MRI.getType(DstReg);
  LLT SrcTy = MRI.getType(SrcReg);
  unsigned int DstTySize = DstTy.getSizeInBits();
  unsigned int SrcTySize = SrcTy.getSizeInBits();
  auto *DstRC = TRI.getRegClassFromLLT(DstTy);
  auto *SrcRC = TRI.getRegClassFromLLT(SrcTy);

  if (DstTySize > SrcTySize) {
    unsigned int OpCode = pISA::zext_16b_8brr;
    if (DstTySize == 64) {
      if (SrcTySize == 16)
        OpCode = pISA::zext_64b_16brr;
      else if (SrcTySize == 32)
        OpCode = pISA::zext_64b_32brr;
      else
        assert(false && "unexpected src size");
    } else if (DstTySize == 32) {
      if (SrcTySize == 16)
        OpCode = pISA::zext_32b_16brr;
      else
        assert(false && "unexpected src size");
    }
    BuildMI(*BB, &I, DL, TII.get(OpCode)).addDef(DstReg).addReg(SrcReg);
  } else if (DstTySize < SrcTySize) {
    unsigned int OpCode = pISA::trunc_32b_64brr;
    if (DstTySize == 32)
      OpCode = pISA::trunc_32b_64brr;
    else if (DstTySize == 16) {
      if (SrcTySize == 32)
        OpCode = pISA::trunc_16b_32brr;
      else if (SrcTySize == 64)
        OpCode = pISA::trunc_16b_64brr;
    } else
      assert(false && "unexpect dst size");
    BuildMI(*BB, &I, DL, TII.get(OpCode)).addDef(DstReg).addReg(SrcReg);
  } else {
    BuildMI(*BB, &I, DL, TII.get(TargetOpcode::COPY))
        .addDef(DstReg)
        .addReg(SrcReg);
  }

  if (!RBI.constrainGenericRegister(SrcReg, *SrcRC, MRI) ||
      !RBI.constrainGenericRegister(DstReg, *DstRC, MRI))
    return false;

  I.eraseFromParent();
  return true;
}

bool pISAInstructionSelector::selectCopy(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  DebugLoc DL = I.getDebugLoc();
  MachineRegisterInfo &MRI = BB->getParent()->getRegInfo();

  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg = I.getOperand(1).getReg();
  LLT DstTy = MRI.getType(DstReg);
  LLT SrcTy = MRI.getType(SrcReg);
  auto *DstRC = TRI.getRegClassFromLLT(DstTy);
  auto *SrcRC = TRI.getRegClassFromLLT(SrcTy);

  if (DstTy.getSizeInBits() != SrcTy.getSizeInBits()) {
    assert(false && "Operands with different bit size!");
    return false;
  }

  BuildMI(*BB, &I, DL, TII.get(TargetOpcode::COPY))
      .addDef(DstReg)
      .addReg(SrcReg);

  if (!RBI.constrainGenericRegister(SrcReg, *SrcRC, MRI) ||
      !RBI.constrainGenericRegister(DstReg, *DstRC, MRI))
    return false;

  I.eraseFromParent();
  return true;
}

bool pISAInstructionSelector::emitBuildVector(
  MachineInstr& InsertPt, Register DstReg, ArrayRef<Register> Srcs) const {
  assert(!Srcs.empty());
  MachineBasicBlock *BB = InsertPt.getParent();
  DebugLoc DL = InsertPt.getDebugLoc();
  MachineRegisterInfo &MRI = BB->getParent()->getRegInfo();

  // A sequence of INSERT_SUBREG's that are later lowered
  // to COPY's is generated.

  const uint32_t NumSrcs = Srcs.size();

  LLT DstTy = MRI.getType(DstReg);
  LLT EltTy = MRI.getType(Srcs[0]);
  const unsigned SrcSize = EltTy.getSizeInBits();
  auto *DstRC = TRI.getRegClassFromLLT(DstTy);

  Register CurVecReg = MRI.createVirtualRegister(DstRC);
  BuildMI(*BB, &InsertPt, InsertPt.getDebugLoc(),
    TII.get(TargetOpcode::IMPLICIT_DEF), CurVecReg);

  if (!RBI.constrainGenericRegister(CurVecReg, *DstRC, MRI))
    return false;

  for (auto [Idx, EltReg] : llvm::enumerate(Srcs)) {
    unsigned SubRegIdx = TRI.getSubRegIdx(SrcSize, Idx);
    Register CurDstReg = (Idx + 1 == NumSrcs) ?
      DstReg :
      MRI.createVirtualRegister(DstRC);

    BuildMI(*BB, &InsertPt, DL, TII.get(TargetOpcode::INSERT_SUBREG), CurDstReg)
      .addReg(CurVecReg)
      .addReg(EltReg)
      .addImm(SubRegIdx);

    if (!RBI.constrainGenericRegister(CurDstReg, *DstRC, MRI))
      return false;

    CurVecReg = CurDstReg;
  }

  return true;
}

bool pISAInstructionSelector::selectBuildVector(MachineInstr &I) const {
  SmallVector<Register> SrcRegs;
  for (uint32_t i = 1; i < I.getNumOperands(); i++)
    SrcRegs.push_back(I.getOperand(i).getReg());

  Register DstReg = I.getOperand(0).getReg();

  if (!emitBuildVector(I, DstReg, SrcRegs))
    return false;

  I.eraseFromParent();
  return true;
}

// GISel seems to lack a SelectionDAG equivalent for G_INTRINSIC_FPTRUNC_ROUND,
// so we custom select it.
bool pISAInstructionSelector::selectFPTruncRound(MachineInstr &I) const {
  MachineBasicBlock *BB = I.getParent();
  DebugLoc DL = I.getDebugLoc();
  MachineRegisterInfo &MRI = BB->getParent()->getRegInfo();

  Register DstReg = I.getOperand(0).getReg();
  Register SrcReg = I.getOperand(1).getReg();
  LLT DstTy = MRI.getType(DstReg);
  LLT SrcTy = MRI.getType(SrcReg);
  auto *DstRC = TRI.getRegClassFromLLT(DstTy);
  auto *SrcRC = TRI.getRegClassFromLLT(SrcTy);
  bool UseFTZ = STI.getTargetLowering()->useFTZ(*MF);
  auto RM = I.getOperand(2).getImm();
  assert(RM >= 0 && RM < 4);

  // 0 - RZ, 1 - RE, 2 - RU, 3 - RD
  unsigned TruncToHalf[2][4] = {{pISA::ftrunc_hf_fr_rz, pISA::ftrunc_hf_fr_re,
                                 pISA::ftrunc_hf_fr_ru, pISA::ftrunc_hf_fr_rd},
                                {pISA::ftrunc_hf_dfr_rz, pISA::ftrunc_hf_dfr_re,
                                 pISA::ftrunc_hf_dfr_ru,
                                 pISA::ftrunc_hf_dfr_rd}};
  // TODO: Does it make sense to have both rounding mode and ftz at the same
  // time?
  unsigned TruncToHalfFTZ[2][4] = {
      {pISA::ftrunc_hf_fr_rz_ftz, pISA::ftrunc_hf_fr_re_ftz,
       pISA::ftrunc_hf_fr_ru_ftz, pISA::ftrunc_hf_fr_rd_ftz},
      {pISA::ftrunc_hf_dfr_rz_ftz, pISA::ftrunc_hf_dfr_re_ftz,
       pISA::ftrunc_hf_dfr_ru_ftz, pISA::ftrunc_hf_dfr_rd_ftz}};
  unsigned TruncToFloat[4] = {pISA::ftrunc_f_dfr_rz, pISA::ftrunc_f_dfr_re,
                              pISA::ftrunc_f_dfr_ru, pISA::ftrunc_f_dfr_rd};
  unsigned TruncToFloatFTZ[4] = {
      pISA::ftrunc_f_dfr_rz_ftz, pISA::ftrunc_f_dfr_re_ftz,
      pISA::ftrunc_f_dfr_ru_ftz, pISA::ftrunc_f_dfr_rd_ftz};
  unsigned opcode;
  if (DstTy == LLT::scalar(16)) {
    int index = SrcTy == LLT::scalar(32) ? 0 : 1;
    opcode = UseFTZ ? TruncToHalfFTZ[index][RM] : TruncToHalf[index][RM];
  } else if (DstTy == LLT::scalar(32)) {
    assert(SrcTy == LLT::scalar(64));
    opcode = UseFTZ ? TruncToFloatFTZ[RM] : TruncToFloat[RM];
  } else
    llvm_unreachable("illegal dst/src type combo for fptrunc");

  BuildMI(*BB, &I, DL, TII.get(opcode)).addDef(DstReg).addReg(SrcReg);

  if (!RBI.constrainGenericRegister(SrcReg, *SrcRC, MRI) ||
      !RBI.constrainGenericRegister(DstReg, *DstRC, MRI))
    return false;

  I.eraseFromParent();
  return true;
}

bool pISAInstructionSelector::selectDbgValue(MachineInstr &I) const {
  // Retain DBG_VALUE MIR opcode, but make it target specific by
  // adding a phony operand. This way, AsmPrinter won't print it
  // as target independent instruction. If we don't add the phony
  // operand, AsmPrinter thinks it's the machine independent
  // version so it print it itself and never invokes pISAAsmPrinter.
  // If we select DBG_VALUE to a custom pseudo op then other
  // passes need to be taught to not mark the pseudo op as "dead".
  // To keep it simple, therefore, we keep DBG_VALUE operation
  // but attach a phony operand. This is still legal because
  // DBG_VALUE is treated as a variadic operation.
  I.addOperand(*I.getParent()->getParent(), MachineOperand::CreateImm(1));
  return true;
}

InstructionSelector::ComplexRendererFns
pISAInstructionSelector::SelectAddr_r(MachineOperand &Root) const {
  MachineRegisterInfo &MRI
    = Root.getParent()->getParent()->getParent()->getRegInfo();

  Register Base = Root.getReg();
  MachineInstr *Def = getDefIgnoringCopies(Base, MRI);

  // Do not select. It is supposed to be handled by SelectAddr_rr or SelectAddr_ri
  if (Def->getOpcode() == TargetOpcode::G_PTR_ADD)
    return std::nullopt;
  if (Def->getOpcode() == TargetOpcode::G_FRAME_INDEX) {
    return {{
      [=](MachineInstrBuilder &MIB) { MIB.add(Def->getOperand(1)); },
      [=](MachineInstrBuilder &MIB) { MIB.addImm(0); }  // [FrameIndex + 0]
    }};
  } else {
    return {{
      [=](MachineInstrBuilder &MIB) { MIB.addReg(Base); },
      [=](MachineInstrBuilder &MIB) { MIB.addImm(0); }  // [$Base + 0]
    }};
  }
}

InstructionSelector::ComplexRendererFns
pISAInstructionSelector::SelectAddr_ri(MachineOperand &Root) const {
  MachineRegisterInfo &MRI
    = Root.getParent()->getParent()->getParent()->getRegInfo();

  MachineInstr *MI =
      getOpcodeDef(TargetOpcode::G_PTR_ADD, Root.getReg(), MRI);
  if (!MI)
    return std::nullopt;

  Register Base = MI->getOperand(1).getReg();
  auto ValAndVReg =
      getIConstantVRegValWithLookThrough(MI->getOperand(2).getReg(), MRI);

  if (!ValAndVReg)
    return std::nullopt;
  int64_t ImmOff = ValAndVReg->Value.getSExtValue();
  MachineInstr *Def = getDefIgnoringCopies(Base, MRI);

  if (Def->getOpcode() == TargetOpcode::G_FRAME_INDEX) {
    return {{
      [=](MachineInstrBuilder &MIB) { MIB.add(Def->getOperand(1)); },
      [=](MachineInstrBuilder &MIB) { MIB.addImm(ImmOff); }  // [FrameIndex + imm]
    }};
  } else {
    return {{
      [=](MachineInstrBuilder &MIB) { MIB.addReg(Base); },
      [=](MachineInstrBuilder &MIB) { MIB.addImm(ImmOff); }  // [$Base + imm]
    }};
  }
}

InstructionSelector::ComplexRendererFns
pISAInstructionSelector::SelectAddr_rr(MachineOperand &Root) const {
  MachineRegisterInfo &MRI
    = Root.getParent()->getParent()->getParent()->getRegInfo();

  MachineInstr *MI =
      getOpcodeDef(TargetOpcode::G_PTR_ADD, Root.getReg(), MRI);
  if (!MI)
    return std::nullopt;

  Register Base = MI->getOperand(1).getReg();
  Register Offset = MI->getOperand(2).getReg();
  MachineInstr *Def = getDefIgnoringCopies(Base, MRI);

  if (Def->getOpcode() == TargetOpcode::G_FRAME_INDEX) {
    return {{
      [=](MachineInstrBuilder &MIB) { MIB.add(Def->getOperand(1)); },
      [=](MachineInstrBuilder &MIB) { MIB.addReg(Offset); }  // [FrameIndex + $Offset]
    }};
  } else {
    return {{
      [=](MachineInstrBuilder &MIB) { MIB.addReg(Base); },
      [=](MachineInstrBuilder &MIB) { MIB.addReg(Offset); }  // [$Base + $Offset]
    }};
  }
}

namespace llvm {
InstructionSelector *
createpISAInstructionSelector(const pISATargetMachine &TM,
                               const pISASubtarget &Subtarget,
                               const RegisterBankInfo &RBI) {
  return new pISAInstructionSelector(TM, Subtarget, RBI);
}
} // namespace llvm
